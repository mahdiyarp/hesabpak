حساب پاک — بلوکچین محلی و مسیر ارتقاء

هدف این ماژول

- ارائهٔ یک دفتر کل محلی (append-only ledger) برای ثبت رویدادهای حساس برنامه (مثلاً صدور توکن، لاگ‌های مهم، عملیات ممیزی) به‌صورت tamper-evident.
- امکان صدور توکن داخلی (رکورد در جدول `tokens`) و ثبت صدور در دفتر کل.

آنچه پیاده شده

1. utils/ledger.py
   - زنجیره محلی در `data/chain.json` ذخیره می‌شود.
   - هر بلاک شامل: index, ts, prev_hash, data, hash, sig
   - امضا با HMAC-SHA256 و کلید `SECRET_KEY` ساخته می‌شود.
   - متدها: get_ledger(), get_chain(), append_event(...), verify_chain().

2. models/backup_models.py
   - مدل `Token` اضافه شد تا رکوردهای صدور توکن را در دیتابیس ثبت کند.

3. app.py
   - هنگام ایجاد کاربر جدید در مسیر /admin/users اگر تنظیم `tokens_per_user` در جدول settings بزرگتر از صفر باشد، به تعداد مشخص توکن صادر و هم در جدول `tokens` و هم در ledger ثبت می‌شود.
   - endpoint مدیریتی `/admin/ledger` برای مشاهدهٔ JSON زنجیره به‌صورت admin-only اضافه شد.

تنظیمات (در DB یا ENV)

- `tokens_per_user` (Setting): مقدار عددی پیش‌فرض 0. اگر بزرگتر از صفر باشد، هنگام ثبت کاربر جدید همان مقدار توکن صادر می‌شود.
- `token_symbol` (Setting): نماد توکن پیش‌فرض (مثلاً `HSP`).
- `SECRET_KEY` (ENV): برای امضای بلاک‌ها استفاده می‌شود؛ اگر کلید تغییر کند، امضاهای فعلی دیگر معتبر به شمار نمی‌آیند.
- `HESABPAK_LEDGER_FILE` (ENV): مسیر فایل زنجیره را می‌توانید بازنویسی کنید؛ پیش‌فرض `data/chain.json` است.

چگونه می‌توان به شبکهٔ عمومی منتقل کرد (مسیر ارتقاء)

گزینهٔ الف — قرارداد هوشمند در اتریوم/OPBNB و پل زدن
- نوشتن یک قرارداد ERC-20 ساده یا ERC-1155 (بسته به نیاز).
- Deploy قرارداد روی شبکهٔ مورد نظر (testnet قبل از mainnet).
- افزودن یک ماژول bridge که هنگام mint داخلی، ابتدا تراکنش mint را به قرارداد ارسال کند (با web3.py) و `tx_ref` را در رکورد Token ذخیره کند.
- نکتهٔ مهم: کلید خصوصی که تراکنش‌ها را امضا می‌کند باید امن نگهداری شود (HSM یا vault یا فایل محافظت‌شده با دسترسی محدود). هزینهٔ گس و مدیریت nonce را مدنظر بگیرید.

گزینهٔ ب — استفاده از سرویس L2 یا rollup برای کاهش هزینه
- استفاده از شبکه‌های لایهٔ دوم یا زنجیره‌های با هزینهٔ پایین (Polygon, BSC, Arbitrum).
- همان جریان: deploy قرارداد، use web3.py to call contract, record tx_ref.

گزینهٔ ج — ثبت هش‌ها در زنجیرهٔ عمومی (not full token)
- اگر هدف اصلی فقط شواهد غیرقابل‌انکار بودن است، می‌توانید هش بلاک محلی را هر دوره (مثلاً هر شب) در یک تراکنش ساده روی اتریوم ثبت کنید (opReturn-like or store hashed payload). این روش شدیداً ارزان‌تر از صدور توکن on-chain است.

موارد امنیتی

- SECRET_KEY را قوی کنید و در متغیرهای محیطی ذخیره کنید.
- برای تعامل با شبکه‌های عمومی از کیف پول/کلید خصوصی امن استفاده کنید (هرگز کلید را در repo قرار ندهید).
- پیاده‌سازی reorg یا rollback برای bridge باید مدنظر باشد: اگر تراکنش روی چین عمومی revert شد، چگونه رفتار محلی را تعدیل می‌کنید؟

مراحل پیشنهادی بعدی

1. تصمیم بگیرید: می‌خواهید توکن داخلی (ثبت محلی) نگه داشته شود یا می‌خواهید فوراً توکن on-chain صادر شود؟
2. اگر on-chain می‌خواهید:
   - من قرارداد ERC20/ERC721 نمونه می‌نویسم و تست‌نت deployment script آماده می‌کنم.
   - سپس web3.py integration و راهنمای ایمن نگهداری کلید را اضافه می‌کنم.
3. اگر فعلاً محلی کافی است:
   - می‌توانم UI مدیریت توکن و صفحهٔ مرور زنجیره را اضافه کنم و endpointهای API امن برای پخش زنجیره یا گرفتن اثبات فراهم کنم.

اگر تأیید کنید، مرحلهٔ بعدی: (الف) اضافه کردن endpoint مدیریتی برای صدور دستی، مشاهده توکن‌ها و دانلود chain.json، و (ب) نوشتن README عملیاتی با دستورالعمل deploy امن برای web3 در آینده.
